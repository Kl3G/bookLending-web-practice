このリポジトリは、Clean Architecture の理解を目的として
設計・実装した図書管理 CLI アプリケーションである。

# アプリ概要

このアプリは、図書管理を行う CLI アプリケーションである。  
図書の貸出、返却、登録、検索、削除、ならびに貸出履歴の参照機能を提供する。

---

## 設計構造と意図

Domain 概念を基盤として定義される一つのルール(要求)を、  
概念、流れ、技術的要素(UI, DBなどの外部保存環境)に分離する  
Clean Architecture の考え方を理解することを目的として、  
図書管理アプリを設計した。

---

## 設計の参考  

- https://blog.cleancoder.com/  
- 『Agile Software Development』（2002/2003）

---

# アプリケーションの中核概念と、それを理解するためのアーキテクチャ基礎概念

---

## アーキテクチャ

異なる変更理由（Responsibility）を基準にモジュールを分離し、依存の方向を制御する。
それで一つのモジュールの変更が、異なる責務を持つ他のモジュールに影響を与えないようにする。
これにより、変更コスト（人の労力）を最小化する。
(安易な判断は、変更時に最も高いコストを生む。)

---

## クラス（オブジェクトの設計図）

一つの抽象的な概念を具体化した境界。
一つの責務を基準に、データとそのデータを扱う行動を結び付けた単位。
これにより、データに対する責任が明確になり、アクセスおよび変更経路が構造的に固定される。

---

## モジュール

一つの責務を持つコード単位。
(クラス、メソッド、関数など)

---

## オブジェクト

クラスを基に生成された実体。

---

## 依存

他のモジュール(クラス・インターフェース・メソッドなど)の
公開された契約（シグニチャ）を知り、それを呼び出している状態。
(より安定したものは、より不安定なものに依存してはならない。)

---

## 結合

異なる理由で変更されるコードが、構造的に一緒に束ねられている状態。
(一つのモジュールの変更が、他のモジュールの変更を強制する。)

---

# アプリケーション設計の流れおよび関連概念
ドメインルール(Business Rule)を基にする。

---

## 1.ドメインルールを基盤とした設計

1) 貸出中でない本は貸し出すことができる。
2) 貸出中でない本は削除できる。
3) 貸出中の本は返却できる。
4) 同じ番号の本はシステム内に登録できない。

---

## 2.ドメインルールから中核概念(Entity)を分離

1) 本：ドメインルールを直接判断するオブジェクト。
2) 貸出：ドメインにおける「貸出」という事実を表現するオブジェクト。

---

## 3.中核概念(Entity)がドメインルールに関係する主要な属性を定義

本は貸出状態を持つ必要がある(state)。
本は番号を持つ必要がある(data)。
※Entityのすべての属性が必ずしもドメインルールである必要はない。

---

## 4.Entityが必要な理由

ドメインルールの判断は、必ずEntityを通して行う。
ルールが各所に分散すると、変更時に修正漏れや不整合が発生する。
したがって、アプリケーションの中核となるドメインルールを一箇所に集約し、保護する。

---

## 5.ドメインルールを現実の一つの要求事項として完成させるための手順(Use Case)の設計

Use Caseの責務は、一つの要求事項を完成させるために、
ドメインルールおよび必要な要素を、どの順序で呼び出すかを決定し、固定することである。
ドメインルールが一つの手順として固定されていない場合、
変更発生時に、ルールの適用漏れや実行順序の乱れが生じる。

---

## 6.Use CaseをUI入力から保護するためのstruct(DTO)の設計

struct(DTO)とは、データのみを持つオブジェクトである。
これは、UI入力に対する責務をstruct(DTO)に分離し、
Use Caseが要求するデータを、一つの意味単位として固定する。
これにより、入力データの欠落や順序ミスなどによって発生したエラーが、
Use Caseのエラーとして誤認されることを防ぐことができる。
一つのモジュールが、自身の責務以外の理由で変更されることは最悪だが、
変更対象の候補になること自体も危険である。

---

## 7.外部保存環境(DBなど)と接続するためのGateway設計

DBへのデータ保存・読み込みの責務をGatewayに分離する。
さらに、外部保存環境は変更(モジュールの差し替えや形式変更など)が発生しやすく、不安定な要素であるため、
モジュールによる構造分離だけでなく、常に抽象(Interface)への依存も考慮する必要がある。
この分離によって、Use Caseが保存手段の変更による影響を受けないようにする。

---

## 8.Use CaseとGatewayを安全に接続するためのInterface(Port)設計

二つのモジュールを構造的に分離し、結合度を下げたとしても、
Use CaseがGatewayの呼び出し箇所に依存すること自体は防げない。
メソッドのシグニチャを合わせる方法で依存を管理することは可能だが、
実装ミスが発生する恐れがある。
そのため、Interfaceを用いて構造的に強制する。
Interface は、変更を人との約束ではなく、強制された構造に委ねる。

---

## 9.ドメインルールを保護するためのPresenter設計

Presenterは UI に渡すデータの形式を強制するオブジェクトである。
Entityを UI にそのまま渡すと、
UI 側でドメインルールを再構成して判断してしまう恐れがある。
これは、ドメインルールが UI に分散することを意味する。
例えば、以下のようなルールがあるとする。
1) 元のルール：貸出中かつ予約中の場合、削除ボタンを表示可能
2) 変更後のルール：貸出中かつ予約中の場合、削除ボタンを表示不可
Entityを UI に直接渡すと、
UI 側で Entity の状態を任意に組み合わせた条件分岐によって、
削除ボタンの表示可否を判断する恐れがある。
この場合、ルール変更時に Entity を修正しても、
UI 側の独自実装にはその変更が反映されない。
その結果、独自に実装したすべての箇所を探して修正することになる。
Presenterは、UI に渡すデータの形式を強制することで、この問題を防止する。

参考
EntityをDBに保存する際にも、Entityのスキーマをそのまま保存しない方がよい。
(保存時にはGateway側で保存形式へ変換)
DBでドメインルールを判断または再構成すること
(クエリで削除可能な本のみを取得するような仕組みなど)を防ぐためである。
DBデータだけを見てルールを判断したくなる状況を作ってはならない。

---

# アプリの問題点

1. GatewayやInterfaceが過剰な責務を持っている。  
(図書の登録・返却だけでなく、他の機能の責務まで Gateway に集中)
2. View Use Caseが外部保存環境に直接依存している。
(Interfaceがまだ定義できていない)
3. index.phpも責務が多すぎる。
(Controllerの概念を理解したうえで、導入する必要がある)

---

# つまずいたところ

この1か月は、機能を実装したり
正常動作を確認したりすることではなく、
将来の変更を見据えて、

- なぜこのコードがここにあるべきなのか  
- なぜここに置いてはいけないのか  

を、初めて深く考えた時間だった。

アーキテクチャという概念自体が抽象的で、
提示される例も仮定に基づくものが多く、理解するのが簡単ではなかったためだ。
また、このレポートを書きながら、私が理解した内容や考え方を
50％も表現できていないことが、恥ずかしく感じられることもあった。

しかし、この機会を通して、
良い設計や変更に強い構造を描くことが本当に楽しいことだと気づけた。

---

# 今後について

良いアーキテクチャは  
変更の影響を最小化するものだけど、  
将来のすべての変更を  
事前に予測することは不可能で、  
その価値は実際に変更が発生するまで  
体感しにくいと言われている。

今後もこの学習を継続し、  
深い理解を基にアプリを変更に強く設計し、  
実際に変更が発生した際に、  
その判断が正しかったかを体感しながら  
経験を積んでいきたいと考えている。
